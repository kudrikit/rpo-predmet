flyway
========

## 목적

node.js의 비동기 환경에 적합한 플로우 컨트롤을 작성한다.


지역급과 전역급을 나누어야 겠다.


지역급은 하나의 알고리즘/로직을 작성하고자할때, 작성되는 것.


지원급을 추가하자. 지원급은 자체는 완성된 로직이 아니지만, 로직에 공통적으로 나오는 블럭을 말한다.
retry
wrap

전역급은 시스템 전체에 통지가 들어가야 하는 것과 같다.
비유하자만, 전역급은 '공지사항'이다.
**이벤트 전파(Publisher/Subscriber) 구조** 가 전역급 솔루션이 되겠다. 


하나의 로직, 알고리즘을 완성 한다고할때, Library를 사용해서 완성할것이다.
또는 단위 함수를 잘 이어 붙이거나...

그러기 위해서는 실행블럭과 실행블럭을 이어서 하나로 만들어야한다.
실행블럭은 필연적으로  `함수`가 되곘다. 

실행가능한 유일한  


## Promises/A 에 대한 생각..

비동기에서 플로우 컨트롤은 고민거리이다.

P/A 모듈은 이것을 동기 구조처럼 만들어서 사용한다. 달리말해, 비동기성을 뒤로 감추어서 생각하지 않고 쓸수 있게 하자는 취지이다.
그러나, 함수의 결과가 P/A 구현체여야만 가능한데, P/A구현체에 서로 상이하면 재사용이 힘들수있다.

게다가 구현을 작성하는 입장에서, 익명 함수를 연속하기 어렵다.
P/A를 직접 생성하고 해야한다.

```
T = new P/A
Something ()-> T.Resolve
T.then ()->
  T = new P/A
  Something ()-> T.Resolve
  T.then ()->
    T = new P/A
    Something ()-> T.Resolve
    T.then ()->

```
함수에 이름을 부여하지 않는다면, 결국 callback 체인과 indent가 복잡해지는 것은 동일하다.


그리고 Error -> All Fail을 작성하기 어렵다.

근본적 물음을 생각해보자 Error가 발생했을 때, 복구 할수 있는가? 

또는 Error가 발생하면 대체 로직을 수행하여, 원하는 최종 결과에 도달할수 있나?

최초의 요청은 곧  결과가 무엇인지를 간접적으로 의미한다. 특정 연산의 실패 상황에서 동등한 백업 연산이 존재한다...?  만약 백업이 실패하면..? 

분명한건 최종적 Error가 발생할수 있고, 이는 최초 요청자에게 Error를 주어야 하며, 실패에 영향을 받는 모든 후속 연산과 의미가 없어지는 연산을 전부 건너 뚸야한다.   
  