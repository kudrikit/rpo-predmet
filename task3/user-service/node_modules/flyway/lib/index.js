// Generated by CoffeeScript 1.7.1
var cutFlowsByArity, debug, exports, flyway, runChain, runFlow, runFork, runReduce, runSeries, unifyErrors, _emptyFn, _fn, _isArray, _isError, _toString,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty;

debug = require('debug')('flyway');

_toString = Object.prototype.toString;

_isArray = Array.isArray || function(obj) {
  return _toString.call(obj) === "[object Array]";
};

_isError = function(obj) {
  return _toString.call(obj) === "[object Error]";
};

_emptyFn = function() {};

cutFlowsByArity = function(fnFlows, arity) {
  var fn, inx, _i, _len;
  for (inx = _i = 0, _len = fnFlows.length; _i < _len; inx = ++_i) {
    fn = fnFlows[inx];
    if (!_isArray(fn) && fn.length === arity) {
      return fnFlows.slice(inx);
    }
  }
  return [];
};

unifyErrors = function(errors) {
  var error, errs;
  errs = errors.filter(function(err) {
    return err;
  });
  error = void 0;
  if (errs.length > 0) {
    error = errs[0];
    error.errors = errors;
  }
  return error;
};

runFork = function(fnFlows, args, outCallback) {
  var join;
  join = flyway.join();
  fnFlows.forEach(function(flow) {
    return flow.apply(null, __slice.call(args).concat([join["in"]()]));
  });
  return join.out(outCallback);
};

runFlow = function(fnFlows, err, args, outCallback) {
  var argsToCall, errorHandlerArity, fn, fnArr, fns;
  errorHandlerArity = args.length + 2;
  if (err) {
    fnFlows = cutFlowsByArity(fnFlows, errorHandlerArity);
  }
  if (fnFlows.length === 0) {
    return outCallback.apply(null, [err].concat(__slice.call(args)));
  }
  fn = fnFlows[0], fns = 2 <= fnFlows.length ? __slice.call(fnFlows, 1) : [];
  if (_isArray(fn)) {
    fnArr = fn.map(function(flow) {
      if (_isArray(flow)) {
        return _fn.flow(flow);
      }
      return flow;
    });
    fn = function() {
      var args, next, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), next = arguments[_i++];
      return runFork(fnArr, args, next);
    };
  }
  argsToCall = args;
  if (fn.length === errorHandlerArity) {
    argsToCall = [err].concat(args);
  }
  return fn.apply(null, __slice.call(argsToCall).concat([function(err) {
    return runFlow(fns, err, args, outCallback);
  }]));
};

runChain = function(fnFlows, args, outCallback) {
  var fn, fnArr, fns;
  debug('runChain', fnFlows, args);
  fn = fnFlows[0], fns = 2 <= fnFlows.length ? __slice.call(fnFlows, 1) : [];
  if (_isArray(fn)) {
    fnArr = fn.map(function(flow) {
      if (_isArray(flow)) {
        return _fn.chain(flow);
      }
      return flow;
    });
    fn = function() {
      var args, next, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), next = arguments[_i++];
      return runFork(fnArr, args, next);
    };
  }
  return fn.apply(null, __slice.call(args).concat([function() {
    var err, output;
    err = arguments[0], output = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (err) {
      return outCallback(err);
    }
    if (fns.length === 0) {
      return outCallback.apply(null, [null].concat(__slice.call(output)));
    }
    return runChain(fns, output, outCallback);
  }]));
};

runReduce = function(data, fn, memo, outCallback) {
  var head, others;
  if (data.length === 0) {
    return outCallback(null, memo);
  }
  head = data[0], others = 2 <= data.length ? __slice.call(data, 1) : [];
  return fn(memo, head, function(err, newMemo) {
    if (err) {
      return outCallback(err);
    }
    return runReduce(others, fn, newMemo, outCallback);
  });
};

runSeries = function(data, fn, results, outCallback) {
  var head, others;
  if (data.length === 0) {
    return outCallback(null, results);
  }
  head = data[0], others = 2 <= data.length ? __slice.call(data, 1) : [];
  return fn(head, function(err, output) {
    if (err) {
      return outCallback(err);
    }
    results.push(output);
    return runSeries(others, fn, results, outCallback);
  });
};

_fn = {};

_fn.join = function(strict) {
  var callOut, errors, finished, fns, outFn, results, resultsObj;
  if (strict == null) {
    strict = true;
  }
  errors = [];
  results = [];
  finished = [];
  outFn = void 0;
  resultsObj = {};
  callOut = function() {
    var allFnished, err;
    allFnished = finished.every(function(v) {
      return v;
    });
    if (allFnished && outFn) {
      err = unifyErrors(errors);
      results.obj = resultsObj;
      return outFn(err, results);
    }
  };
  fns = {
    "in": function(varName) {
      var inx, varInx;
      if (varName == null) {
        varName = null;
      }
      varName = varName;
      inx = errors.length;
      errors.push(void 0);
      results.push(void 0);
      finished.push(false);
      if (varName) {
        resultsObj[varName] = resultsObj[varName] || [];
        varInx = results.length;
        resultsObj[varName].push(void 0);
      }
      return function() {
        var err, values;
        err = arguments[0], values = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (finished[inx] && strict) {
          throw new Error('should call `callback` once');
        }
        errors[inx] = err;
        if (values.length === 1) {
          values = values[0];
        }
        results[inx] = values;
        if (varName) {
          resultsObj[varName][inx] = values;
        }
        finished[inx] = true;
        return callOut();
      };
    },
    out: function(fn) {
      outFn = fn;
      return callOut();
    }
  };
  return fns;
};

_fn.series = function(fn) {
  return function(data, outCallback) {
    return runSeries(data, fn, [], outCallback);
  };
};

_fn.map = function(fn) {
  return function(data, outCallback) {
    var join, key, value, _outCallback;
    join = flyway.join();
    if (_isArray(data)) {
      data.forEach(function(args) {
        if (!_isArray(args)) {
          args = [args];
        }
        return fn.apply(null, __slice.call(args).concat([join["in"]()]));
      });
    } else {
      for (key in data) {
        if (!__hasProp.call(data, key)) continue;
        value = data[key];
        fn(key, value, join["in"](key));
      }
      _outCallback = outCallback;
      outCallback = function(err, results, next) {
        if (err) {
          next(err);
        }
        return _outCallback(null, results.obj);
      };
    }
    return join.out(outCallback);
  };
};

_fn.reduce = function(memo, fn) {
  return function(data, outCallback) {
    return runReduce(data, fn, memo, outCallback);
  };
};

_fn.retry = function(tryLimit, fn) {
  return function() {
    var args, argsToCall, fnDone, outCallback, tryCnt, _i;
    args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), outCallback = arguments[_i++];
    tryCnt = 0;
    fnDone = function() {
      var err, output;
      err = arguments[0], output = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      tryCnt++;
      if (err && tryCnt < tryLimit) {
        return fn.apply(null, argsToCall);
      } else {
        return outCallback.apply(null, [err].concat(__slice.call(output)));
      }
    };
    argsToCall = args.concat(fnDone);
    return fn.apply(null, argsToCall);
  };
};

_fn["do"] = function() {
  var args, fn, _i;
  args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), fn = arguments[_i++];
  return fn.apply(null, args);
};

_fn.delay = function(msec, fn) {
  return function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return setTimeout(function() {
      return fn.apply(null, args);
    }, msec);
  };
};

_fn.wrap = function(preFns, postFns) {
  if (!_isArray(preFns)) {
    preFns = [preFns];
  }
  if (!_isArray(postFns)) {
    postFns = [postFns];
  }
  return function(inFns) {
    if (!_isArray(inFns)) {
      inFns = [inFns];
    }
    return _fn.flow(__slice.call(preFns).concat(__slice.call(inFns), __slice.call(postFns)));
  };
};

_fn.fork = function(flowFns) {
  return function() {
    var args, outCallback, _i;
    args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), outCallback = arguments[_i++];
    if (typeof outCallback !== 'function') {
      args.push(outCallback);
      outCallback = function() {};
    }
    return runFork(flowFns, args, outCallback);
  };
};

_fn.chain = function(chainFns) {
  return function() {
    var args, outCallback, _i;
    args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), outCallback = arguments[_i++];
    if (typeof outCallback !== 'function') {
      args.push(outCallback);
      outCallback = function() {};
    }
    return runChain(chainFns, args, outCallback);
  };
};

_fn.flow = function(flowFns) {
  return function() {
    var args, err, first, outCallback, _i;
    args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), outCallback = arguments[_i++];
    first = args[0];
    err = null;
    if (first === null || first === void 0 || _isError(first)) {
      err = args.shift();
    }
    if (typeof outCallback !== 'function') {
      args.push(outCallback);
      outCallback = function() {};
    }
    return runFlow(flowFns, err, args, outCallback);
  };
};

_fn.flow.run = function() {
  var args, fnFlows, _i;
  args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), fnFlows = arguments[_i++];
  return _fn["do"].apply(_fn, __slice.call(args).concat([_emptyFn], [_fn.flow(fnFlows)]));
};

_fn.chain.run = function() {
  var args, fnFlows, _i;
  args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), fnFlows = arguments[_i++];
  return _fn["do"].apply(_fn, __slice.call(args).concat([_emptyFn], [_fn.chain(fnFlows)]));
};

flyway = _fn.flow;

flyway.flow = _fn.flow;

flyway.chain = _fn.chain;

flyway.map = _fn.map;

flyway.fork = _fn.fork;

flyway.each = _fn.map;

flyway.reduce = _fn.reduce;

flyway.series = _fn.series;

flyway.retry = _fn.retry;

flyway.wrap = _fn.wrap;

flyway.join = _fn.join;

flyway.delay = _fn.delay;

flyway["do"] = _fn["do"];

module.exports = exports = flyway;
